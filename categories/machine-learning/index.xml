<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Machine Learning on Te(k|ch) blog</title>
    <link>https://www.randhome.io/categories/machine-learning/</link>
    <description>Recent content in Machine Learning on Te(k|ch) blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 16 Jul 2016 12:52:42 +0200</lastBuildDate>
    <atom:link href="https://www.randhome.io/categories/machine-learning/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Machine learning for malware detection</title>
      <link>https://www.randhome.io/blog/2016/07/16/machine-learning-for-malware-detection/</link>
      <pubDate>Sat, 16 Jul 2016 12:52:42 +0200</pubDate>
      
      <guid>https://www.randhome.io/blog/2016/07/16/machine-learning-for-malware-detection/</guid>
      <description>

&lt;p&gt;Plop,&lt;/p&gt;

&lt;p&gt;I have been reading many articles about Machine Learning recently, and it seems to be the new hype technology so I wanted to play a bit with these algorithms to better understand the principles behind it. If you don&amp;rsquo;t know machine learning, you should to read this &lt;a href=&#34;http://www.r2d3.us/visual-intro-to-machine-learning-part-1/&#34;&gt;awesome article&lt;/a&gt; or &lt;a href=&#34;https://redshiftzero.github.io/2015/08/29/Manipulation-and-Machine-Learning/&#34;&gt;this one&lt;/a&gt;. This article was largely inspired by &lt;a href=&#34;https://blog.socialcops.com/engineering/machine-learning-python&#34;&gt;this one which analyze the Titanic data&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;machine-learning-and-classification&#34;&gt;Machine Learning and Classification&lt;/h2&gt;

&lt;p&gt;So the idea of machine learning is to let the algorithm learn by itself the best parameters from data in order to make good predictions. There are many different applications, in our case we will consider using machine learning algorithm to classify binaries between legitimate and malicious binaries. This idea is &lt;a href=&#34;http://ieeexplore.ieee.org/xpl/login.jsp?tp=&amp;amp;arnumber=924286&amp;amp;url=http%3A%2F%2Fieeexplore.ieee.org%2Fxpls%2Fabs_all.jsp%3Farnumber%3D924286&#34;&gt;not&lt;/a&gt; &lt;a href=&#34;http://ieeexplore.ieee.org/xpl/login.jsp?tp=&amp;amp;arnumber=1297538&amp;amp;url=http%3A%2F%2Fieeexplore.ieee.org%2Fxpls%2Fabs_all.jsp%3Farnumber%3D1297538&#34;&gt;new&lt;/a&gt; and Adobe has even released a tool called &lt;a href=&#34;https://github.com/adobe-security/Malware-classifier&#34;&gt;Adobe Malware Classifier&lt;/a&gt; at &lt;a href=&#34;https://www.blackhat.com/html/webcast/webcast-2012-polymorphicmalware.html&#34;&gt;Black Hat 2012&lt;/a&gt; but it will be a nice exercice to see how to use machine learning.&lt;/p&gt;

&lt;p&gt;Here is the plan that we will follow :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Extract as many features as we can from binaries to have a good training data set. The features have to be integers or floats to be usable by the algorithms&lt;/li&gt;
&lt;li&gt;Identify the best features for the algorithm : we should select the information that best allows to differenciate legitimate files from malware.&lt;/li&gt;
&lt;li&gt;Choose a classification algorithm&lt;/li&gt;
&lt;li&gt;Test the efficiency of the algorithm and identify the False Positive/False negative rate&lt;/li&gt;
&lt;/ul&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://www.randhome.io/media/doctor5.jpg&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Let&amp;#39;s go!&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;h2 id=&#34;feature-extraction-from-binaries&#34;&gt;Feature Extraction from binaries&lt;/h2&gt;

&lt;p&gt;As I said earlier, machine learning only uses integer or float data as features for detection, but it is not a big deal as most &lt;a href=&#34;https://manalyzer.org/report/1e27184759cc4099c0da73b152408281&#34;&gt;PE parameters&lt;/a&gt; are integers (field size, addresses, parameters&amp;hellip;). So I extracted all the PE parameters I could by using pefile, and considered especially the one that are relevant for identifying malware, like the entropy of section for packer detection. As we can only have a fix list of feature (and not one per section), I extracted the Mean, Minimum and Maximum of entropy for sections and resources.&lt;/p&gt;

&lt;p&gt;Here is the final list of feature extracted : &lt;em&gt;Name, md5, Machine, SizeOfOptionalHeader, Characteristics, MajorLinkerVersion, MinorLinkerVersion, SizeOfCode, SizeOfInitializedData, SizeOfUninitializedData, AddressOfEntryPoint, BaseOfCode, BaseOfData, ImageBase, SectionAlignment, FileAlignment, MajorOperatingSystemVersion, MinorOperatingSystemVersion, MajorImageVersion, MinorImageVersion, MajorSubsystemVersion, MinorSubsystemVersion, SizeOfImage, SizeOfHeaders, CheckSum, Subsystem, DllCharacteristics, SizeOfStackReserve, SizeOfStackCommit, SizeOfHeapReserve, SizeOfHeapCommit, LoaderFlags, NumberOfRvaAndSizes, SectionsNb, SectionsMeanEntropy, SectionsMinEntropy, SectionsMaxEntropy, SectionsMeanRawsize, SectionsMinRawsize, SectionMaxRawsize, SectionsMeanVirtualsize, SectionsMinVirtualsize, SectionMaxVirtualsize, ImportsNbDLL, ImportsNb, ImportsNbOrdinal, ExportNb, ResourcesNb, ResourcesMeanEntropy, ResourcesMinEntropy, ResourcesMaxEntropy, ResourcesMeanSize, ResourcesMinSize, ResourcesMaxSize, LoadConfigurationSize, VersionInformationSize.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Many other feature could have been considered, for instance the number of suspicious function imported, or the number of section with a abnormal name, but it will be for another time (I ended the script a bit late in the night and forgot to implement those ¯\&lt;em&gt;(ツ)&lt;/em&gt;/¯ ).&lt;/p&gt;

&lt;p&gt;Regarding the dataset, we need to have an important number of both legitimate and malicious file:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;For legitimate file, I gathered all the Windows binaries (exe + dll) from Windows 2008, Windows XP and Windows 7 32 and 64 bits, so exactly 41323 binaries. It is not a perfect dataset as there is only Microsoft binaries and not binaries from application which could have different properties, but I did not find any easy way to gather easily a lot of legitimate binaries, so it will be enough for playing&lt;/li&gt;
&lt;li&gt;Regarding malware, I used a part of &lt;a href=&#34;https://virusshare.com/&#34;&gt;Virus Share&lt;/a&gt; collection by downloading one archive (the 134th) and kept only PE files (96724 different files).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I used &lt;a href=&#34;https://github.com/erocarrera/pefile&#34;&gt;pefile&lt;/a&gt; to extract all these features from the binaries and store them in a csv file (ugly code is &lt;a href=&#34;https://github.com/Te-k/malware-classification/blob/master/generatedata.py&#34;&gt;here&lt;/a&gt;, &lt;a href=&#34;https://github.com/Te-k/malware-classification/blob/master/data.csv&#34;&gt;data&lt;/a&gt; are here).&lt;/p&gt;

&lt;p&gt;And here we are with a large CSV file (138048 lines) ready for playing!&lt;/p&gt;

&lt;h2 id=&#34;feature-selection&#34;&gt;Feature Selection&lt;/h2&gt;

&lt;p&gt;The idea of feature selection is to reduce the 54 features extracted to a smaller set of feature which are the most relevant for differentiating legitimate binaries from malware.&lt;/p&gt;

&lt;p&gt;To play with the data, we will use &lt;a href=&#34;http://pandas.pydata.org/&#34;&gt;Pandas&lt;/a&gt; and then &lt;a href=&#34;http://scikit-learn.org/stable/index.html&#34;&gt;Scikit&lt;/a&gt; which largely uses the &lt;a href=&#34;http://www.numpy.org/&#34;&gt;numpy&lt;/a&gt; library:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;data = pd.read_csv(&#39;data.csv&#39;, sep=&#39;|&#39;)
legit_binaries = data[0:41323].drop([&#39;legitimate&#39;], axis=1)
malicious_binaries = data[41323::].drop([&#39;legitimate&#39;], axis=1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So a first way of doing it manually could be to check the different values and see if there is a difference between the two groups. For instance, we can take the parameter FileAlignment (which defines the alignment of sections and is by default 0x200 bytes) and check the values :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;In [8]: legit_binaries[&#39;FileAlignment&#39;].value_counts()
Out[8]:
512      36843
4096      4313
128         89
32          40
65536       36
16           2
Name: FileAlignment, dtype: int64

In [9]: malicious_binaries[&#39;FileAlignment&#39;].value_counts()
Out[9]:
512     94612
4096     2074
128        18
1024       15
64          2
32          1
16          1
2048        1
Name: FileAlignment, dtype: int64

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So if we remove the 20 malware having weird values here, there is not much difference on this value between the two groups, this parameter would not make a good feature for us.&lt;/p&gt;

&lt;p&gt;On the other side, some values are clearly interesting like the max entropy of the sections which can be represented with an histogram:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;In [12]: plt.hist([legit_binaries[&#39;SectionsMaxEntropy&#39;], malicious_binaries[&#39;SectionsMaxEntropy&#39;]], range=[0,8], normed=True, color=[&amp;quot;green&amp;quot;, &amp;quot;red&amp;quot;],label=[&amp;quot;legitimate&amp;quot;, &amp;quot;malicious&amp;quot;])
Out[12]:
([array([ 0.        ,  0.00120095,  0.00129333,  0.00914567,  0.08896238,
        0.04665213,  0.12609933,  0.55631513,  0.37580371,  0.04452738]),
  array([  9.04607814e-05,   0.00000000e+00,   1.29229688e-05,
           1.55075625e-04,   5.16918751e-04,   1.51198735e-03,
           6.04794938e-03,   8.64675840e-02,   3.81266348e-01,
                                            7.73930754e-01])],
  array([ 0. ,  0.8,  1.6,  2.4,  3.2,  4. ,  4.8,  5.6,  6.4,  7.2,  8. ]),
  &amp;lt;a list of 2 Lists of Patches objects&amp;gt;)

In [13]: plt.legend()
Out[13]: &amp;lt;matplotlib.legend.Legend at 0x7f15da65ee10&amp;gt;

In [14]: plt.show()
&lt;/code&gt;&lt;/pre&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://www.randhome.io/media/sectionsmaxentropy.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;But there is a more efficient way of selecting features : some algorithms have been developed to identify the most interesting features and reduce the dimensionality of the data set (see &lt;a href=&#34;http://scikit-learn.org/stable/modules/feature_selection.html&#34;&gt;the Scikit page for Feature Selection&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;In our case, we will use the &lt;a href=&#34;http://scikit-learn.org/stable/modules/feature_selection.html#tree-based-feature-selection&#34;&gt;Tree-based feature selection&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;In [15]: X = data.drop([&#39;Name&#39;, &#39;md5&#39;, &#39;legitimate&#39;], axis=1).values

In [16]: y = data[&#39;legitimate&#39;].values

In [17]: fsel = ske.ExtraTreesClassifier().fit(X, y)

In [20]: model = SelectFromModel(fsel, prefit=True)

In [21]: X_new = model.transform(X)

In [22]: X.shape
Out[22]: (110258, 54)

In [23]: X_new.shape
Out[23]: (110258, 11)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So in this case, the algorithm selected 11 important features among the 54, and we can notice that indeed the SectionsMaxEntropy is selected but other features (like the Machine value) are surprisingly also good parameters for this classification :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;In [1]: nb_features = X_new.shape[1]

In [2]: indices = np.argsort(fsel.feature_importances_)[::-1][:nb_features]

In [3]: for f in range(nb_features):
   ...:         print(&amp;quot;%d. feature %s (%f)&amp;quot; % (f + 1, data.columns[2+indices[f]], fsel.feature_importances_[indices[f]]))
      ...:
      1. feature Characteristics (0.187685)
      2. feature Machine (0.173019)
      3. feature ImageBase (0.099215)
      4. feature Subsystem (0.091090)
      5. feature MajorSubsystemVersion (0.077067)
      6. feature SectionsMaxEntropy (0.046552)
      7. feature SizeOfOptionalHeader (0.040004)
      8. feature ResourcesMaxEntropy (0.035633)
      9. feature VersionInformationSize (0.027091)
      10. feature SectionsNb (0.020562)
      11. feature DllCharacteristics (0.018640)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;selection-of-the-classification-algorithm&#34;&gt;Selection of the Classification Algorithm&lt;/h2&gt;

&lt;p&gt;The best classification algorithm depends on many parameters and some of them (like SVM) have a lot of different parameters and can be difficult to correctly configure. So I used a simple option: I tested some of them with default parameters and selected the best one (I removed SVM because it does not handle well dataset with many features):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;algorithms = {
        &amp;quot;DecisionTree&amp;quot;: tree.DecisionTreeClassifier(max_depth=10),
        &amp;quot;RandomForest&amp;quot;: ske.RandomForestClassifier(n_estimators=50),
        &amp;quot;GradientBoosting&amp;quot;: ske.GradientBoostingClassifier(n_estimators=50),
        &amp;quot;AdaBoost&amp;quot;: ske.AdaBoostClassifier(n_estimators=100),
        &amp;quot;GNB&amp;quot;: GaussianNB()
    }

results = {}
print(&amp;quot;\nNow testing algorithms&amp;quot;)
for algo in algorithms:
    clf = algorithms[algo]
    clf.fit(X_train, y_train)
    score = clf.score(X_test, y_test)
    print(&amp;quot;%s : %f %%&amp;quot; % (algo, score*100))
    results[algo] = score

winner = max(results, key=results.get)
print(&#39;\nWinner algorithm is %s with a %f %% success&#39; % (winner, results[winner]*100))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s run it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Now testing algorithms
GNB : 69.478450 %
DecisionTree : 98.960522 %
RandomForest : 99.351684 %
AdaBoost : 98.558493 %
GradientBoosting : 98.761318 %

Winner algorithm is RandomForest with a 99.351684 % success
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we recompute the false positive/false negative rate on the test data, we obtain :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;False positive : 0.568241 %&lt;/li&gt;
&lt;li&gt;False negative : 0.830565 %&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So it&amp;rsquo;s a 99.35% success, so more than the &lt;a href=&#34;https://www.blackhat.com/docs/webcast/TowardsClassificationofPolymorphicMalware-Final.pdf&#34;&gt;Adobe&lt;/a&gt; work (98.21%) but still with the RandomForest algorithm.&lt;/p&gt;

&lt;p&gt;The whole code for feature selection and algorithm test is available &lt;a href=&#34;https://github.com/Te-k/malware-classification/blob/master/learning.py&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;reuse-the-algorithm&#34;&gt;Reuse the algorithm&lt;/h2&gt;

&lt;p&gt;So now we want to reuse this algorithms for detection, we can just save the object and the feature list :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;joblib.dump(algorithms[winner], &#39;classifier/classifier.pkl&#39;)
open(&#39;classifier/features.pkl&#39;, &#39;w&#39;).write(pickle.dumps(features))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I have then implemented a &lt;a href=&#34;https://github.com/Te-k/malware-classification/blob/master/checkpe.py&#34;&gt;simple tool&lt;/a&gt; which load the feature list and the classifier, extract the PE feature and predict if a binary is malicious or not:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt; python2 checkpe.py ~/virusshare/VirusShare_000b296200f7b8fffbc584f3eac864b2
The file VirusShare_000b296200f7b8fffbc584f3eac864b2 is malicious
&amp;gt; python2 checkpe.py ~/legitimate/explorer.exe
The file explorer.exe is legitimate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As I like the new &lt;a href=&#34;https://manalyzer.org/&#34;&gt;Manalyzer&lt;/a&gt; platform, I have also developed &lt;a href=&#34;https://github.com/Te-k/malware-classification/blob/master/checkmanalyzer.py&#34;&gt;a script&lt;/a&gt; which download the PE properties and predict if the binary is legitimate of not:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;python2 checkmanalyzer.py https://manalyzer.org/report/a9ea61c5ae7eab02c63955336a7c7efe
The file a9ea61c5ae7eab02c63955336a7c7efe is legitimate
&amp;gt; python2 checkmanalyzer.py https://manalyzer.org/report/9c5c27494c28ed0b14853b346b113145
The file 9c5c27494c28ed0b14853b346b113145 is malicious
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;why-it-s-not-enough&#34;&gt;Why it&amp;rsquo;s not enough?&lt;/h2&gt;

&lt;p&gt;First, a bit of vocabulary for measuring IDS accuracy (taken from &lt;a href=&#34;https://en.wikipedia.org/wiki/Sensitivity_and_specificity&#34;&gt;Wikipedia&lt;/a&gt;):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Sensitivity&lt;/strong&gt; : the proportion of positives identified as such (or true positive rate)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Specificity&lt;/strong&gt; : the proportion of negatives correctly identified as such (or true negative)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;False Positive Rate&lt;/strong&gt; (FPR) : the proportion of events badly identified as positive over the total number of negatives&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;False Negative Rate&lt;/strong&gt; (FNR) : the proportion of events badly identified as negative over the total number of positives&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So why 99.35% is not enough?&lt;/p&gt;

&lt;p&gt;Because you can&amp;rsquo;t just consider the sensitivity/specificity of the algorithm, you have to consider the malicious over legitimate traffic ratio to understand how many alerts will be generated by the IDS. And this ratio is extremely low.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s consider the you have 1 malicious event every 10 000 event (it&amp;rsquo;s a really high ratio) and 1 000 000 events per day, you will have :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;100 malicious events, 99 identified by the tool and 1 false negative (0.83% FNR but let&amp;rsquo;s consider 1% here)&lt;/li&gt;
&lt;li&gt;999 900 legitimate events, around 6499 identified as malicious (0.65% FPR)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So in the end, &lt;strong&gt;the analyst would received 6598 alerts per day with only 99 true positive in it (1.5%)&lt;/strong&gt;. Your IDS is useless here. (Out of curiosity, the same problem applies when &lt;a href=&#34;http://www.jaddo.fr/2016/06/19/et-mes-fesses-elles-sont-roses-mes-fesses/&#34;&gt;detecting cancer at large scale&lt;/a&gt; (in French))&lt;/p&gt;

&lt;p&gt;If we take our example, a standard Windows 7 install has around 15000 binary files (it seems to be very different depending on the version, but let&amp;rsquo;s say 15000), which means that in average 97 files would be detected incorrectly as malicious. And that&amp;rsquo;s a bad antivirus.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;So it was a fun example of machine learning utilization. I like how Pandas and Scikit make machine learning easy to use in python (and Scikit is really well explained and documented!). I was really surprised to have such good results without any effort for configuring the algorithm specifically for this context, and it shows that the Adobe tool is not as good as I thought.&lt;/p&gt;

&lt;p&gt;Still, it is interesting to remind the IDS problem and show it concretely (just after self-congratulation for such a good sensitivity :).&lt;/p&gt;

&lt;p&gt;If you have any question, comment or idea to continue playing with this dataset, let me know on &lt;a href=&#34;https://twitter.com/tenacioustek&#34;&gt;Twitter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Here are some nice references on this topic:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://pandas.pydata.org/pandas-docs/stable/10min.html&#34;&gt;Learning Pandas in 10 minutes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.socialcops.com/engineering/machine-learning-python&#34;&gt;Would You Survive the Titanic? A Guide to Machine Learning in Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://scikit-learn.org/stable/index.html&#34;&gt;Scikit Learn&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Adéu!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Edit 21/07/16: improved the dataset with more legitimate binaries. Updated the results&lt;/em&gt;
&lt;em&gt;Edit 02/08/16: explained why it&amp;rsquo;s not enough&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;This article was written mainly while listening Glenn Gould &lt;a href=&#34;https://www.youtube.com/watch?v=Ah392lnFHxM&#34;&gt;Goldberg Variations (1955)&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>